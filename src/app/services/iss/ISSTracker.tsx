"use client";
import React, { useEffect, useState } from "react";
import { MapContainer, TileLayer, Marker, Polyline, Popup, useMap } from "react-leaflet";
import { Icon, LatLngBounds, Map as LeafletMap } from "leaflet";
import { twoline2satrec, propagate, gstime, eciToGeodetic } from "satellite.js";
import type { EciVec3 } from "satellite.js";
import styles from "./map.module.css";
import "leaflet/dist/leaflet.css";

interface OrbitPoint {
    position: [number, number];
    type: "past" | "future";
}

interface ISSData {
    latitude: number;
    longitude: number;
    altitude: number;
    velocity: number;
    visibility: string;
    timestamp: number;
}

// MapEffect Ïª¥Ìè¨ÎÑåÌä∏Ïóê ÌÉÄÏûÖ Ï∂îÍ∞Ä
interface MapEffectProps {
  setMapInstance: React.Dispatch<React.SetStateAction<LeafletMap | null>>;
}

// MapEffect Ïª¥Ìè¨ÎÑåÌä∏ Ï∂îÍ∞Ä - Îßµ Ïù∏Ïä§ÌÑ¥Ïä§Ïóê Ï†ëÍ∑ºÌïòÍ∏∞ ÏúÑÌïú Ïª¥Ìè¨ÎÑåÌä∏
const MapEffect = ({ setMapInstance }: MapEffectProps) => {
  const map = useMap();
  
  useEffect(() => {
    setMapInstance(map);
    
    // ÎßµÏù¥ Î°úÎìúÎêú ÌõÑ ÌÅ¨Í∏∞ Îã§Ïãú Í≥ÑÏÇ∞
    setTimeout(() => {
      map.invalidateSize();
    }, 300);
  }, [map, setMapInstance]);
  
  return null;
};

const ISSTracker = () => {
    const [userPosition, setUserPosition] = useState<[number, number] | null>(null);
    const [issPosition, setIssPosition] = useState<[number, number]>([0, 0]);
    const [mapType, setMapType] = useState<"default" | "satellite">("satellite");
    const [orbitPath, setOrbitPath] = useState<OrbitPoint[]>([]);
    const [issData, setIssData] = useState<ISSData | null>(null);
    const [isMobile, setIsMobile] = useState(false);
    const [visibilityIcon, setVisibilityIcon] = useState("üåû");
    const [showStats, setShowStats] = useState(true);
    const [mapKey, setMapKey] = useState(Date.now()); // Îßµ Î¶¨Î†åÎçîÎßÅÏùÑ ÏúÑÌïú ÌÇ§
    const [mapInstance, setMapInstance] = useState<LeafletMap | null>(null); // ÌÉÄÏûÖ Ï∂îÍ∞Ä

    useEffect(() => {
        const checkMobile = () => {
            const mobile = window.innerWidth <= 900;
            setIsMobile(mobile);
            // ÌôîÎ©¥ ÌÅ¨Í∏∞ Î≥ÄÍ≤Ω Ïãú ÏßÄÎèÑ ÌÇ§ ÏóÖÎç∞Ïù¥Ìä∏Î°ú Í∞ïÏ†ú Î¶¨Î†åÎçîÎßÅ
            setMapKey(Date.now());
        };
        
        checkMobile();
        window.addEventListener('resize', checkMobile);
        
        return () => window.removeEventListener('resize', checkMobile);
    }, []);

    // Îßµ ÌÅ¨Í∏∞ Ïû¨Ï°∞Ï†ï
    useEffect(() => {
        if (mapInstance) {
            setTimeout(() => {
                mapInstance.invalidateSize();
            }, 300);
        }
    }, [mapInstance, mapKey, isMobile, showStats]);

    useEffect(() => {
        if (issData?.visibility === 'daylight') {
            setVisibilityIcon("üåû");
        } else {
            setVisibilityIcon("üåô");
        }
    }, [issData?.visibility]);

    const maxBounds: [[number, number], [number, number]] = [
        [-90, -180],
        [90, 180],
    ];

    // Ïª§Ïä§ÌÖÄ ÏïÑÏù¥ÏΩò
    const issIcon = new Icon({
        iconUrl: "/images/iss.png",
        iconSize: [40, 40],
        iconAnchor: [20, 20],
    });

    const userIcon = new Icon({
        iconUrl: "/images/my.svg",
        iconSize: [32, 32],
        iconAnchor: [16, 16],
    });

    useEffect(() => {
        if (typeof window !== "undefined" && navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(
                (position) => setUserPosition([position.coords.latitude, position.coords.longitude]),
                (error) => console.error("Error:", error)
            );
        }
    }, []);
    // ISS TLE Îç∞Ïù¥ÌÑ∞ Í∞ÄÏ†∏Ïò§Í∏∞
    const fetchTLEData = async () => {
        try {
            const response = await fetch("/api/iss/tle", {
                cache: 'no-store',
                next: { revalidate: 7200 }
            });
            
            if (!response.ok) {
                throw new Error("Failed to fetch TLE data");
            }
            
            const result = await response.json();
            
            if (result.error) {
                console.error(result.error);
                throw new Error(result.error);
            }
            
            return result.data;
        } catch (error) {
            console.error("Error fetching TLE data:", error);
            throw error;
        }
    };

    // Í∂§ÎèÑ Í≥ÑÏÇ∞
    useEffect(() => {
        const calculateOrbits = async () => {
            try {
                const data = await fetchTLEData();
                const lines = data.split("\n");
                const issLines = lines.slice(0, 3);
                const satrec = twoline2satrec(issLines[1], issLines[2]);

                if (satrec) {
                    const orbits: OrbitPoint[] = [];
                    const currentTime = new Date();

                    // Í≥ºÍ±∞ Í∂§ÎèÑ Í≥ÑÏÇ∞
                    for (let i = 180; i >= 0; i--) {
                        const pastTime = new Date(currentTime.getTime() - i * 60000);
                        const positionAndVelocity = propagate(satrec, pastTime);
                        const gmst = gstime(pastTime);

                        const position = positionAndVelocity.position as EciVec3<number>;
                        if (position && "x" in position) {
                            const geodetic = eciToGeodetic(position, gmst);
                            const lat = (geodetic.latitude * 180) / Math.PI;
                            const lon = (geodetic.longitude * 180) / Math.PI;
                            
                            if (!isNaN(lat) && !isNaN(lon)) {
                                orbits.push({
                                    position: [lat, lon],
                                    type: "past",
                                });
                            }
                        }
                    }

                    // ÎØ∏Îûò Í∂§ÎèÑ Í≥ÑÏÇ∞
                    for (let i = 0; i <= 180; i++) {
                        const futureTime = new Date(currentTime.getTime() + i * 60000);
                        const positionAndVelocity = propagate(satrec, futureTime);
                        const gmst = gstime(futureTime);

                        const position = positionAndVelocity.position as EciVec3<number>;
                        if (position && "x" in position) {
                            const geodetic = eciToGeodetic(position, gmst);
                            const lat = (geodetic.latitude * 180) / Math.PI;
                            const lon = (geodetic.longitude * 180) / Math.PI;
                            
                            if (!isNaN(lat) && !isNaN(lon)) {
                                orbits.push({
                                    position: [lat, lon],
                                    type: "future",
                                });
                            }
                        }
                    }

                    setOrbitPath(orbits);
                }
            } catch (error) {
                console.error("Orbit calculation error:", error);
            }
        };

        calculateOrbits();
        const interval = setInterval(calculateOrbits, 300000); // 5Î∂ÑÎßàÎã§ Í∞±Ïã†
        return () => clearInterval(interval);
    }, []);

    // Fetch ISS orbit path - NaN Í∞íÏùÑ Ï≤†Ï†ÄÌûà ÌïÑÌÑ∞ÎßÅ
    useEffect(() => {
        const calculateOrbits = async () => {
            try {
                const response = await fetch("https://www.celestrak.com/NORAD/elements/stations.txt");
                const data = await response.text();
                const lines = data.split("\n");
                const issLines = lines.slice(0, 3);
                const satrec = twoline2satrec(issLines[1], issLines[2]);

                if (satrec) {
                    const orbits: OrbitPoint[] = [];
                    const currentTime = new Date();

                    // Past orbits (3 hours back)
                    for (let i = 180; i >= 0; i--) {
                        try {
                            const pastTime = new Date(currentTime.getTime() - i * 60000);
                            const positionAndVelocity = propagate(satrec, pastTime);
                            const gmst = gstime(pastTime);

                            const position = positionAndVelocity.position as EciVec3<number>;
                            if (position && "x" in position) {
                                const geodetic = eciToGeodetic(position, gmst);
                                const lat = (geodetic.latitude * 180) / Math.PI;
                                const lon = (geodetic.longitude * 180) / Math.PI;
                                
                                // NaN Ï≤¥ÌÅ¨
                                if (!isNaN(lat) && !isNaN(lon)) {
                                    orbits.push({
                                        position: [lat, lon],
                                        type: "past",
                                    });
                                }
                            }
                        } catch (error) {
                            console.warn("Error calculating past orbit point:", error);
                            // Ïò§Î•ò Î∞úÏÉù Ïãú Ìï¥Îãπ ÏßÄÏ†êÏùÄ Í±¥ÎÑàÎúÄ
                            continue;
                        }
                    }

                    // Future orbits (3 hours ahead)
                    for (let i = 0; i <= 180; i++) {
                        try {
                            const futureTime = new Date(currentTime.getTime() + i * 60000);
                            const positionAndVelocity = propagate(satrec, futureTime);
                            const gmst = gstime(futureTime);

                            const position = positionAndVelocity.position as EciVec3<number>;
                            if (position && "x" in position) {
                                const geodetic = eciToGeodetic(position, gmst);
                                const lat = (geodetic.latitude * 180) / Math.PI;
                                const lon = (geodetic.longitude * 180) / Math.PI;
                                
                                // NaN Ï≤¥ÌÅ¨
                                if (!isNaN(lat) && !isNaN(lon)) {
                                    orbits.push({
                                        position: [lat, lon],
                                        type: "future",
                                    });
                                }
                            }
                        } catch (error) {
                            console.warn("Error calculating future orbit point:", error);
                            // Ïò§Î•ò Î∞úÏÉù Ïãú Ìï¥Îãπ ÏßÄÏ†êÏùÄ Í±¥ÎÑàÎúÄ
                            continue;
                        }
                    }

                    setOrbitPath(orbits);
                }
            } catch (error) {
                console.error("Error:", error);
            }
        };

        calculateOrbits();
        const interval = setInterval(calculateOrbits, 60000);
        return () => clearInterval(interval);
    }, []);

    useEffect(() => {
        const fetchISSData = async () => {
            try {
                const response = await fetch("https://api.wheretheiss.at/v1/satellites/25544");
                const data = await response.json();
                setIssData(data);
                setIssPosition([data.latitude, data.longitude]);
            } catch (error) {
                console.error("Error fetching ISS data:", error);
            }
        };
        fetchISSData();
        const interval = setInterval(fetchISSData, 1000);
        return () => clearInterval(interval);
    }, []);

    const formatTime = (timestamp: number) => {
        const date = new Date(timestamp * 1000);
        const kst = new Date(date.getTime() + (9 * 60 * 60 * 1000));
        const utc = date;
        const formatOptions: Intl.DateTimeFormatOptions = {
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false
        };
        return {
            kst: kst.toLocaleTimeString('ko-KR', formatOptions),
            utc: utc.toLocaleTimeString('ko-KR', formatOptions)
        };
    };

    // Í∞úÏÑ†Îêú renderOrbits Ìï®Ïàò - NaN Í∞íÏùÑ Ï≤†Ï†ÄÌûà ÌïÑÌÑ∞ÎßÅ
    const renderOrbits = () => {
        // Ïú†Ìö®Ìïú Ï¢åÌëúÎßå ÌïÑÌÑ∞ÎßÅ
        const validOrbitPath = orbitPath.filter(point => 
            !isNaN(point.position[0]) && !isNaN(point.position[1])
        );
        
        if (validOrbitPath.length < 2) {
            return null; // Ïú†Ìö®Ìïú Ìè¨Ïù∏Ìä∏Í∞Ä 2Í∞ú ÎØ∏ÎßåÏù¥Î©¥ ÏïÑÎ¨¥Í≤ÉÎèÑ Î†åÎçîÎßÅÌïòÏßÄ ÏïäÏùå
        }
        
        const segments: { past: [number, number][][]; future: [number, number][][] } = {
            past: [],
            future: [],
        };
        let currentPastSegment: [number, number][] = [];
        let currentFutureSegment: [number, number][] = [];

        validOrbitPath.forEach((point, index) => {
            if (index > 0) {
                const prevLon = validOrbitPath[index - 1].position[1];
                const currentLon = point.position[1];

                // Í≤ΩÎèÑ Ï∞®Ïù¥Í∞Ä ÌÅ∞ Í≤ΩÏö∞ ÏÑ∏Í∑∏Î®ºÌä∏ Î∂ÑÎ¶¨ (180ÎèÑ Í≤ΩÍ≥Ñ ÎÑòÏñ¥Í∞ÄÎäî Í≤ΩÏö∞)
                if (Math.abs(currentLon - prevLon) > 180) {
                    if (point.type === "past" && currentPastSegment.length > 0) {
                        segments.past.push([...currentPastSegment]);
                        currentPastSegment = [];
                    } else if (point.type === "future" && currentFutureSegment.length > 0) {
                        segments.future.push([...currentFutureSegment]);
                        currentFutureSegment = [];
                    }
                }
            }

            if (point.type === "past") {
                currentPastSegment.push(point.position);
            } else {
                currentFutureSegment.push(point.position);
            }
        });

        // ÎÇ®ÏùÄ ÏÑ∏Í∑∏Î®ºÌä∏ Ï∂îÍ∞Ä
        if (currentPastSegment.length > 0) segments.past.push(currentPastSegment);
        if (currentFutureSegment.length > 0) segments.future.push(currentFutureSegment);

        // Í∞Å ÏÑ∏Í∑∏Î®ºÌä∏Ïóê Ï∂©Î∂ÑÌïú Ï¢åÌëúÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏
        const validSegments = {
            past: segments.past.filter(segment => segment.length > 1),
            future: segments.future.filter(segment => segment.length > 1)
        };
        
        return (
            <>
                {validSegments.past.map((segment, index) => (
                    <Polyline
                        key={`past-${index}`}
                        positions={segment}
                        color="#FF4136"
                        weight={3}
                        opacity={0.7}
                        dashArray="5,8"
                    />
                ))}
                {validSegments.future.map((segment, index) => (
                    <Polyline
                        key={`future-${index}`}
                        positions={segment}
                        color="#0088cc"
                        weight={3}
                        opacity={0.8}
                    />
                ))}
            </>
        );
    };

    const toggleStats = () => {
        setShowStats(!showStats);
    };

    return (
        <div className={styles.modernContainer}>
            <div className={styles.mapSection}>
                <MapContainer
                    key={mapKey}
                    center={[0, 0]}
                    zoom={isMobile ? 1 : 2}
                    className={styles.modernMap}
                    scrollWheelZoom={true}
                    maxBounds={maxBounds}
                    minZoom={isMobile ? 1 : 2}
                >
                    <MapEffect setMapInstance={setMapInstance} />
                    
                    <TileLayer
                        url={
                            mapType === "default"
                                ? "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                                : "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"
                        }
                        noWrap={true}
                        bounds={maxBounds}
                    />
                    {userPosition && (
                        <Marker position={userPosition} icon={userIcon}>
                            <Popup>ÎÇ¥ ÏúÑÏπò</Popup>
                        </Marker>
                    )}
                    <Marker position={issPosition} icon={issIcon}>
                        <Popup>
                            <b>Íµ≠Ï†úÏö∞Ï£ºÏ†ïÍ±∞Ïû• ÌòÑÏû¨ ÏúÑÏπò</b>
                            <br />
                            ÏúÑÎèÑ: {issData?.latitude.toFixed(2)}¬∞ | Í≤ΩÎèÑ: {issData?.longitude.toFixed(2)}¬∞
                        </Popup>
                    </Marker>
                    {renderOrbits()}
                </MapContainer>
                
                <div className={styles.mapControls}>
                    <button
                        onClick={() => setMapType(mapType === "default" ? "satellite" : "default")}
                        className={styles.modernButton}
                    >
                        {mapType === "default" ? "ÏúÑÏÑ± ÏßÄÎèÑ" : "Í∏∞Î≥∏ ÏßÄÎèÑ"}
                    </button>
                    <button onClick={toggleStats} className={styles.modernButton}>
                        {showStats ? "Ï†ïÎ≥¥ Ïà®Í∏∞Í∏∞" : "Ï†ïÎ≥¥ Î≥¥Í∏∞"}
                    </button>
                </div>
            </div>
            {showStats && (
                <div className={styles.infoPanel}>
                    <div className={styles.statsCard}>
                        <div className={styles.cardHeader}>
                            <h2 className={styles.cardTitle}>ISS Ïã§ÏãúÍ∞Ñ ÏúÑÏπò</h2>
                            <span 
                                className={`${styles.statusBadge} ${issData?.visibility === 'daylight' ? styles.daylight : styles.nighttime}`}
                            >
                                {visibilityIcon} {issData?.visibility === 'daylight' ? "Ï£ºÍ∞Ñ" : "ÏïºÍ∞Ñ"}
                            </span>
                        </div>
                        
                        <div className={styles.statsGrid}>
                            <div className={styles.statItem}>
                                <div className={styles.statLabel}>ÏúÑÎèÑ</div>
                                <div className={styles.statValue}>{issData?.latitude.toFixed(2)}¬∞</div>
                            </div>
                            <div className={styles.statItem}>
                                <div className={styles.statLabel}>Í≤ΩÎèÑ</div>
                                <div className={styles.statValue}>{issData?.longitude.toFixed(2)}¬∞</div>
                            </div>
                            <div className={styles.statItem}>
                                <div className={styles.statLabel}>Í≥†ÎèÑ</div>
                                <div className={styles.statValue}>{issData?.altitude.toFixed(2)} km</div>
                            </div>
                            <div className={styles.statItem}>
                                <div className={styles.statLabel}>ÏÜçÎèÑ</div>
                                <div className={styles.statValue}>{issData?.velocity.toFixed(0)} km/h</div>
                            </div>
                            <div className={styles.statItem}>
                                <div className={styles.statLabel}>ÏãúÍ∞Ñ (ÌïúÍµ≠/UTC)</div>
                                <div className={styles.statValue}>
                                    {issData && formatTime(issData.timestamp).kst} / {issData && formatTime(issData.timestamp).utc}
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div className={styles.videoCard}>
                        <div className={styles.cardHeader}>
                            <span className={styles.cardTitle}>ISS Ïã§ÏãúÍ∞Ñ ÏòÅÏÉÅ</span>
                        </div>
                        <div className={styles.videoWrapper}>
                            <iframe
                                width="100%"
                                height="100%"
                                src="https://www.youtube.com/embed/xRPjKQtRXR8?autoplay=1&mute=1"
                                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                                allowFullScreen
                            ></iframe>
                        </div>
                        <div className={styles.infoNote}>
                            <p>NASAÏóêÏÑú Ï†úÍ≥µÌïòÎäî Íµ≠Ï†úÏö∞Ï£ºÏ†ïÍ±∞Ïû• Ïã§ÏãúÍ∞Ñ ÌôîÎ©¥ÏûÖÎãàÎã§.</p>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};

export default ISSTracker;